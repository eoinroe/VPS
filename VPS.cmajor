graph Synth [[ main ]]
{
    input event std::midi::Message midiIn;
    output stream float out;

    input event
    {
        float horizontal [[ name: "Horizontal",   min: 0, max: 1, init: 0.5, unit: ""]];
        float vertical   [[ name: "Vertical",     min: 0, max: 5, init: 0.5, unit: ""]];
    }

    let voiceCount = 8;

    node
    {
        voices = Voice[voiceCount];
        voiceAllocator = std::voices::VoiceAllocator (voiceCount);
    }

    connection
    {
        // Convert the midi message to a our std::notes messages and forward to the voice allocator
        midiIn -> std::midi::MPEConverter -> voiceAllocator;

        // Plumb the voice allocator to the voices array
        voiceAllocator.voiceEventOut -> voices.eventIn;

        horizontal -> voices.input1;
        vertical   -> voices.input2;

        // Sum the voices audio out to the output
        voices -> std::levels::ConstantGain (float, 0.1f) -> out;
    }
}

graph Voice
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    output stream float out;
    
    input event
    {
        float input1;
        float input2;
    } 

    node
    {
        noteToFrequency = NoteToFrequency;
        envelope = std::envelopes::FixedASR (0.01f, 2.5f);
        phasor = std::oscillators::Phasor (float32);
        phaseshaper = vps::Processor;
    }

    connection
    {
        eventIn -> noteToFrequency -> phasor.frequencyIn;
        eventIn -> envelope.eventIn;

        input1 -> phaseshaper.horizontal;
        input2 -> phaseshaper.vertical;

        phasor  -> phaseshaper.in;
        (envelope.gainOut * phaseshaper.out) -> out;
    }
}

// Determine the note frequency from the pitch (midi note)
processor NoteToFrequency
{
    input event std::notes::NoteOn eventIn;
    output event float32 frequencyOut;

    event eventIn (std::notes::NoteOn e)
    {
        frequencyOut <- std::notes::noteToFrequency (e.pitch);
    }
}

namespace vps 
{
    struct InflectionPoint { float d, v; }

    float twoDimensionalPhaseDistortion(const float& x, const InflectionPoint& p)
    {
        // Piecewise function expressed with simple conditional logic.
        if (x <= p.d)
            return p.v * x / p.d;
        else
            return (1.0f - p.v) * (x - p.d) / (1.0f - p.d) + p.v;
    }

    void aliasingSuppression(const float& phaseshaper, float& out, const float& v) 
    {
        float modifiedPhaseshaper = 0.0f;
        float b = fmod(v, 1.0f);
        
        if (0 < b && b <= 0.5f) {
            modifiedPhaseshaper = fmod(phaseshaper, 1.0f) / (2.0f * b);
        }
        else if (0.5f < b && b < 1.0f) {
            modifiedPhaseshaper = fmod(phaseshaper, 1.0f) / b;
        }
        
        // When applied to equation (1), the incomplete segment is rendered as a smooth full-cycle sinusoid,
        // which is then scaled and offset in relation to c = cos(2Ï€b).
        float c = cos(float(twoPi * b));
        
        if (0 < b && b <= 0.5f) {
            out = (((1.0f - c) * out) - 1.0f - c) / 2.0f;
        }
        else if (b > 0.5f || modifiedPhaseshaper > 0.5f) {
            out = (((1.0f + c) * out) + 1.0f - c) / 2.0f;
        }
    }

    processor Processor(float initialFrequency = 440.0f)
    {
        input  stream float in;
        output stream float out;

        input event
        {
            float horizontal;
            float vertical;
        }

        // Sinusoid
        var p = InflectionPoint(0.5f, 0.5f);
        bool antiAliasing = true;

        // (0, 0) also produces a sinewave - but initializing the inflection point this way causes the audio driver to crash!
        // let p = InflectionPoint(0.0f, 0.0f);

        event horizontal (float d)            { p.d = d; }
        event vertical   (float v)            { p.v = v; }

        void main()
        {
            loop 
            {
                float vps = twoDimensionalPhaseDistortion(in, p);    // A phaseshaper acting on an input signal.
                float signal = -cos(float(twoPi * vps));

                if (antiAliasing) {
                    if (vps > floor(p.v)) {
                        aliasingSuppression(vps, signal, p.v);
                    }
                }

                out <- signal;

                advance();
            }
        }
    }
}