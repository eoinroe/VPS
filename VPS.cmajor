
/*
    This file was auto-generated by the cmaj VScode extension!
    https://cmajor.dev
*/

graph Synth [[ main ]]
{
    input event std::midi::Message midiIn;
    output stream float out;

    input event
    {
        float horizontal [[ name: "Horizontal",   min: 0, max: 1, init: 0.5, unit: ""]];
        float vertical   [[ name: "Vertical",     min: 0, max: 5, init: 0.5, unit: ""]];
    }

    let voiceCount = 8;

    node
    {
        voices = Voice[voiceCount];
        voiceAllocator = std::voices::VoiceAllocator (voiceCount);
    }

    connection
    {
        // Convert the midi message to a our std::notes messages and forward to the voice allocator
        midiIn -> std::midi::MPEConverter -> voiceAllocator;

        // Plumb the voice allocator to the voices array
        voiceAllocator.voiceEventOut -> voices.eventIn;

        horizontal -> voices.myInput1;
        vertical   -> voices.myInput2;

        // Sum the voices audio out to the output
        voices -> std::levels::ConstantGain (float, 0.1f) -> out;
    }
}

graph Voice
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    output stream float out;
    
    input event
    {
        float myInput1;
        float myInput2;
    } 

    node
    {
        noteToFrequency = NoteToFrequency;
        envelope = std::envelopes::FixedASR (0.01f, 0.1f);
        phasor = std::oscillators::Phasor (float32);
        phaseshaper = vps::Processor;
    }

    connection
    {
        eventIn -> noteToFrequency -> phasor.frequencyIn;
        eventIn -> envelope.eventIn;

        myInput1 -> phaseshaper.horizontal;
        myInput2 -> phaseshaper.vertical;

        phasor  -> phaseshaper.in;
        (envelope.gainOut * phaseshaper.out) -> out;
    }
}

// Determine the note frequency from the pitch (midi note)
processor NoteToFrequency
{
    input event std::notes::NoteOn eventIn;
    output event float32 frequencyOut;

    event eventIn (std::notes::NoteOn e)
    {
        frequencyOut <- std::notes::noteToFrequency (e.pitch);
    }
}

namespace vps 
{
    struct InflectionPoint { float d, v; }

    float twoDimensionalPhaseDistortion(const float x, const InflectionPoint p)
    {
        // Piecewise function expressed with simple conditional logic.
        if (x <= p.d)
            return p.v * x / p.d;
        else
            return (1.0f - p.v) * (x - p.d) / (1.0f - p.d) + p.v;
    }

    processor Processor(float initialFrequency = 440.0f)
    {
        input  stream float in;
        output stream float out;

        input event
        {
            float horizontal;
            float vertical;
        }

        // Sinusoid
        var p = InflectionPoint(0.5f, 0.5f);

        // (0, 0) also produces a sinewave - but initializing the inflection point this way causes the audio driver to crash!
        // let p = InflectionPoint(0.0f, 0.0f);

        event horizontal (float d)            { p.d = d; }
        event vertical   (float v)            { p.v = v; }

        void main()
        {
            loop 
            {
                float x = float (twoPi * twoDimensionalPhaseDistortion(in, p));    // A phaseshaper acting on an input signal.
                out <- -cos(x);

                advance();
            }
        }
    }
}