
/*
    This file was auto-generated by the cmaj VScode extension!
    https://cmajor.dev
*/

/*

// Here's a very simple graph that plays a sine-wave to get you started..
graph Graph  [[ main ]]
{
    input oscillator.horizontal;
    input oscillator.vertical;

    // Our processor has a single floating point output stream:
    output stream float out;

    // we'll create a sinewave generator node, using the standard library:
    node phasor = std::oscillators::Phasor (float, 440);
    node oscillator = vps::Processor;

    // and we'll connect the sinewave to our output stream via a fixed
    // gain processor, which will reduce its level to be less annoying:
    connection phasor -> oscillator.in;
    connection oscillator -> std::levels::ConstantGain (float, 0.1f) -> out;
}

*/

graph Synth [[ main ]]
{
    input event std::midi::Message midiIn;
    output stream float out;

    let voiceCount = 8;

    node
    {
        voices = Voice[voiceCount];
        voiceAllocator = std::voices::VoiceAllocator (voiceCount);
    }

    connection
    {
        // Convert the midi message to a our std::notes messages and forward to the voice allocator
        midiIn -> std::midi::MPEConverter -> voiceAllocator;

        // Plumb the voice allocator to the voices array
        voiceAllocator.voiceEventOut -> voices.eventIn;

        // Sum the voices audio out to the output
        voices -> std::levels::ConstantGain (float, 0.1f) -> out;
    }
}

graph Voice
{
    input event (std::notes::NoteOn, std::notes::NoteOff) eventIn;
    output stream float out;

    input event
    {
        float horizontal [[ name: "Horizontal",   min: 0, max: 1, init: 0.5, unit: ""]];
        float vertical   [[ name: "Vertical",     min: 0, max: 5, init: 0.5, unit: ""]];
    }

    // event horizontal (float d)            { p.d = d; }
    // event vertical   (float v)            { p.v = v; }

    node
    {
        noteToFrequency = NoteToFrequency;
        envelope = std::envelopes::FixedASR (0.01f, 0.1f);
        phasor = std::oscillators::Phasor (float32);
        phaseshaper = vps::Processor;
    }

    connection
    {
        eventIn -> noteToFrequency -> phasor.frequencyIn;
        eventIn -> envelope.eventIn;
        phasor  -> phaseshaper.in;
        (envelope.gainOut * phaseshaper.out) -> out;
    }
}

// Determine the note frequency from the pitch (midi note)
processor NoteToFrequency
{
    input event std::notes::NoteOn eventIn;
    output event float32 frequencyOut;

    event eventIn (std::notes::NoteOn e)
    {
        frequencyOut <- std::notes::noteToFrequency (e.pitch);
    }
}

namespace vps 
{
    struct InflectionPoint { float d, v; }

    float twoDimensionalPhaseDistortion(const float x, const InflectionPoint p)
    {
        // Piecewise function expressed with simple conditional logic.
        if (x <= p.d)
            return p.v * x / p.d;
        else
            return (1.0f - p.v) * (x - p.d) / (1.0f - p.d) + p.v;
    }

    processor Processor(float initialFrequency = 440.0f)
    {
        input  stream float in;
        output stream float out;

        var p = InflectionPoint(0.5f, 0.5f);

        // (0, 0) also produces a sinewave - but initializing the inflection point causes the audio driver to crash!
        // let p = InflectionPoint(0.0f, 0.0f);

        void main()
        {
            loop 
            {
                float x = float (twoPi * twoDimensionalPhaseDistortion(in, p));    // A phaseshaper acting on an input signal.
                out <- -cos(x);

                advance();
            }
        }
    }
}